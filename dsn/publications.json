[{
    "title": "Quicksort Ruby",
    "author": "Maxime Bédard",
    "date": "01-12-2014",
    "description": "Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(n log n) algorithms.[1] Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort. Quicksort can be implemented with an in-place partitioning algorithm, so the entire sort can be done with only O(log n) additional space used by the stack during the recursion.[2]",
    "language": "ruby",
    "snippet": "class QuickSort\n\ndef self.sort!(keys)\nquick(keys,0,keys.size-1)\nend\n\nprivate\n\ndef self.quick(keys, left, right)\nif left < right\npivot = partition(keys, left, right)\nquick(keys, left, pivot-1)\nquick(keys, pivot+1, right)\nend\nkeys\nend\n\ndef self.partition(keys, left, right)\nx = keys[right]\ni = left-1\nfor j in left..right-1\nif keys[j] <= x\ni += 1\nkeys[i], keys[j] = keys[j], keys[i]\nend\nend\nkeys[i+1], keys[right] = keys[right], keys[i+1]\ni+1\nend\n\nend\n",
    "comments": [{
        "value": "Hello! This exemple looks brilliant!",
        "author": "Gaston",
        "image": "1.jpg",
        "date":"23-11-2014"
      },

      {
        "value": "wekhfwiefiwefhiwehfiuhwe wlefhwoeihfoweihf",
        "author": "Henry",
        "image": "4.jpg",
        "date":"22-11-2014"
      },

      {
        "value": "qiwouoqiskjvnoehowierg",
        "author": "Roger",
        "image": "2.jpg",
        "date":"20-11-2014"
      },


      {
        "value": "wroeuorgieroigjeorgjoerjogeorijojoiiojojoi",
        "author": "Marcel",
        "image": "3.jpg",
        "date":"10-11-2014"
      }

    ]

  }, {
    "title": "Quicksort Scala",
    "author": "Maxime Bédard",
    "date": "26-11-2014",
    "description": "Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(n log n) algorithms.[1] Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort. Quicksort can be implemented with an in-place partitioning algorithm, so the entire sort can be done with only O(log n) additional space used by the stack during the recursion.[2]",
    "language": "scala",
    "snippet": "def qsort(l: List[Int]): List[Int] = {\n  l match {\n    case List() => l\n    case _ =>  qsort(for(x <- l.tail if x < l.head) yield x) ::: List(l.head) ::: qsort(for(x <-1.tail if x >= l.head) yield x)\n  }\n}\n",
    "comments": [

    ]
  }, {
    "title": "Quicksort Go",
    "author": "Maxime Bédard",
    "date": "26-11-2014",
    "description": "Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare. Quicksort is often faster in practice than other O(n log n) algorithms.[1] Additionally, quicksort's sequential and localized memory references work well with a cache. Quicksort is a comparison sort and, in efficient implementations, is not a stable sort. Quicksort can be implemented with an in-place partitioning algorithm, so the entire sort can be done with only O(log n) additional space used by the stack during the recursion.[2]",
    "language": "go",
    "snippet": "func QSort(data []int) {\n  if len(data) < 2 {\n    return\n  }\n  pivot := data[0]\n  l, r := 1, len(data) - 1\n  for l <= r {\n    for l <= r && data[l] <= pivot {\n      l ++\n    }\n    for r >= l && data[r] >= pivot {\n      r --\n    }\n    if l < r {\n      data[l], data[r] = data[r], data[l]\n    }\n  }\n  \n  if r > 0 {\n    data[0], data[r] = data[r], data[0]\n    qsort(data[0:r])\n  }\n  qsort(data[l:])\n}\n",
    "comments": [{
      "value": "Hello! This exemple looks brilliant!",
      "author": "Gaston",
      "image": "1.jpg",
      "date":"23-11-2014"
    },

    {
      "value": "wlefhoewfoerern eiorfhoergnvekrhvoernvlejrfoi",
      "author": "Henry",
      "image": "4.jpg",
      "date":"22-11-2014"
    },

    {
      "value": "sdoifuweoflwe fm lnweiofhwefknwekfhiuwhef",
      "author": "Roger",
      "image": "2.jpg",
      "date":"20-11-2014"
    },


    {
      "value": "wroeuorgieroigjeorgjoerjogeorijojoiiojojoi",
      "author": "Marcel",
      "image": "3.jpg",
      "date":"10-11-2014"
    }

  ]
  }



]
